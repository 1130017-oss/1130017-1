<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>貪吃蛇遊戲</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            touch-action: none; /* 防止在移動設備上滑動時滾動頁面 */
        }
        .touch-button {
            transition: transform 0.1s ease-in-out;
        }
        .touch-button:active {
            transform: scale(0.95);
        }
        /* 全螢幕模式樣式 */
        #main-content:-webkit-full-screen {
            background-color: #111827; /* bg-gray-900 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            width: 100%;
            height: 100%;
        }
        #main-content:fullscreen {
            background-color: #111827; /* bg-gray-900 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            width: 100%;
            height: 100%;
        }
        #main-content:fullscreen .game-canvas-container {
            width: auto;
            height: 80vh; /* 讓畫布容器變高 */
            max-width: 100%;
            flex-grow: 1; /* 允許它佔用空間 */
        }
        #main-content:-webkit-full-screen .game-canvas-container {
            width: auto;
            height: 80vh; /* 讓畫布容器變高 */
            max-width: 100%;
            flex-grow: 1; /* 允許它佔用空間 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

<main id="main-content" class="w-full flex flex-col items-center">
    <div class="w-full max-w-lg mx-auto text-center">
        <div class="flex items-center justify-center relative mb-2">
            <h1 class="text-4xl font-bold text-emerald-400">貪吃蛇遊戲</h1>
            <button id="fullscreenButton" title="切換全螢幕" class="absolute right-0 top-1/2 -translate-y-1/2 p-2 bg-gray-700 rounded-lg hover:bg-gray-600 transition">
                <svg id="fullscreenIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1v4m0 0h-4m4-4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 0h-4m4 4l-5-5" />
                </svg>
                <svg id="exitFullscreenIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                     <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 8V4h4m4 12v4h-4M8 16H4v-4m12-4h4V8" />
                </svg>
            </button>
        </div>
        <p class="text-gray-400 mb-4">用方向鍵或滑動螢幕來控制蛇</p>
        <div class="bg-gray-800 rounded-lg p-4 mb-4 shadow-lg">
            <span class="text-lg text-gray-400">分數：</span>
            <span id="score" class="text-2xl font-bold text-white">0</span>
        </div>
    </div>

    <div class="relative w-full max-w-lg aspect-square game-canvas-container">
        <canvas id="gameCanvas" class="bg-gray-800 rounded-lg shadow-2xl w-full h-full"></canvas>
        <!-- 遊戲結束畫面 -->
        <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center rounded-lg hidden">
            <h2 class="text-5xl font-extrabold text-red-500 mb-4">遊戲結束</h2>
            <p class="text-xl mb-2">你的分數是：<span id="finalScore" class="font-bold">0</span></p>
            <button id="restartButton" class="mt-4 bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg transition duration-300 transform hover:scale-105">
                重新開始
            </button>
        </div>
    </div>

    <!-- 手機觸控按鈕 -->
    <div id="touchControls" class="mt-6 grid grid-cols-3 gap-3 w-48 md:hidden">
        <div></div>
        <button data-direction="up" class="touch-button bg-gray-700 p-4 rounded-lg shadow-md flex justify-center items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg>
        </button>
        <div></div>
        <button data-direction="left" class="touch-button bg-gray-700 p-4 rounded-lg shadow-md flex justify-center items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>
        </button>
        <div class="bg-gray-800 rounded-lg"></div>
        <button data-direction="right" class="touch-button bg-gray-700 p-4 rounded-lg shadow-md flex justify-center items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
        </button>
        <div></div>
        <button data-direction="down" class="touch-button bg-gray-700 p-4 rounded-lg shadow-md flex justify-center items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
        </button>
        <div></div>
    </div>
</main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const mainContent = document.getElementById('main-content');
            const fullscreenButton = document.getElementById('fullscreenButton');
            const fullscreenIcon = document.getElementById('fullscreenIcon');
            const exitFullscreenIcon = document.getElementById('exitFullscreenIcon');
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const gameOverScreen = document.getElementById('gameOverScreen');
            const finalScoreElement = document.getElementById('finalScore');
            const restartButton = document.getElementById('restartButton');
            const touchControls = document.getElementById('touchControls');

            // 檢查是否支援全螢幕，若不支援則隱藏按鈕
            if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled) {
                fullscreenButton.style.display = 'none';
            }

            const gridSize = 20;
            let canvasSize;
            let tileCount;

            let snake, food, score, direction, dx, dy, isGameOver, gameSpeed, gameInterval;

            function setupCanvas() {
                const container = canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight);
                canvas.width = size;
                canvas.height = size;
                canvasSize = size;
                tileCount = Math.floor(canvasSize / gridSize);
            }

            function initializeGame() {
                // 初始蛇的位置和長度
                snake = [{ x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }];
                
                // 初始食物位置
                generateFood();

                // 遊戲變數
                score = 0;
                direction = 'right';
                dx = 1;
                dy = 0;
                isGameOver = false;
                gameSpeed = 150; // 遊戲速度 (毫秒)

                // 更新UI
                scoreElement.textContent = score;
                gameOverScreen.classList.add('hidden');
                gameOverScreen.classList.remove('flex');

                // 清除舊的遊戲循環並開始新的
                if (gameInterval) clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, gameSpeed);
            }
            
            // 遊戲主循環
            function gameLoop() {
                if (isGameOver) {
                    clearInterval(gameInterval);
                    showGameOver();
                    return;
                }
                update();
                draw();
            }

            // 更新遊戲狀態
            function update() {
                const head = { x: snake[0].x + dx, y: snake[0].y + dy };
                snake.unshift(head);

                // 吃到食物
                if (head.x === food.x && head.y === food.y) {
                    score++;
                    scoreElement.textContent = score;
                    generateFood();
                    // 加速遊戲
                    if (gameSpeed > 50) {
                       gameSpeed -= 2;
                       clearInterval(gameInterval);
                       gameInterval = setInterval(gameLoop, gameSpeed);
                    }
                } else {
                    snake.pop();
                }

                // 檢查碰撞
                checkCollision();
            }

            // 繪製遊戲畫面
            function draw() {
                // 清除畫布
                ctx.fillStyle = '#1f2937'; // bg-gray-800
                ctx.fillRect(0, 0, canvasSize, canvasSize);

                // 繪製蛇
                ctx.fillStyle = '#34d399'; // emerald-400
                snake.forEach((part, index) => {
                    ctx.beginPath();
                    // 使用 ctx.roundRect (如果瀏覽器支援) 繪製圓角矩形，否則用普通矩形
                    if (ctx.roundRect) {
                        ctx.roundRect(part.x * gridSize, part.y * gridSize, gridSize - 1, gridSize - 1, 4);
                    } else {
                        ctx.rect(part.x * gridSize, part.y * gridSize, gridSize - 1, gridSize - 1);
                    }
                    ctx.fill();
                    // 蛇頭用不同顏色
                    if (index === 0) {
                        ctx.fillStyle = '#a7f3d0'; // emerald-200
                        ctx.fill();
                        ctx.fillStyle = '#34d399';
                    }
                });

                // 繪製食物
                ctx.fillStyle = '#ef4444'; // red-500
                ctx.beginPath();
                if (ctx.roundRect) {
                    ctx.roundRect(food.x * gridSize, food.y * gridSize, gridSize - 1, gridSize - 1, 6);
                } else {
                    ctx.rect(food.x * gridSize, food.y * gridSize, gridSize - 1, gridSize - 1);
                }
                ctx.fill();
            }

            // 產生食物
            function generateFood() {
                let newFoodPosition;
                do {
                    newFoodPosition = {
                        x: Math.floor(Math.random() * tileCount),
                        y: Math.floor(Math.random() * tileCount)
                    };
                } while (isFoodOnSnake(newFoodPosition));
                food = newFoodPosition;
            }
            
            function isFoodOnSnake(position) {
                return snake.some(part => part.x === position.x && part.y === position.y);
            }

            // 檢查碰撞
            function checkCollision() {
                const head = snake[0];

                // 撞牆
                if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                    isGameOver = true;
                }

                // 撞到自己
                for (let i = 1; i < snake.length; i++) {
                    if (head.x === snake[i].x && head.y === snake[i].y) {
                        isGameOver = true;
                        break;
                    }
                }
            }

            // 顯示遊戲結束畫面
            function showGameOver() {
                finalScoreElement.textContent = score;
                gameOverScreen.classList.remove('hidden');
                gameOverScreen.classList.add('flex');
            }

            // 處理鍵盤輸入
            function handleKeyPress(e) {
                const keyPressed = e.key;

                if (keyPressed === 'ArrowUp' || keyPressed.toLowerCase() === 'w') {
                    dx = 0; dy = -1; direction = 'up';
                }
                if (keyPressed === 'ArrowDown' || keyPressed.toLowerCase() === 's') {
                    dx = 0; dy = 1; direction = 'down';
                }
                if (keyPressed === 'ArrowLeft' || keyPressed.toLowerCase() === 'a') {
                    dx = -1; dy = 0; direction = 'left';
                }
                if (keyPressed === 'ArrowRight' || keyPressed.toLowerCase() === 'd') {
                    dx = 1; dy = 0; direction = 'right';
                }
            }
            
            // 處理觸控按鈕
            function handleTouch(e) {
                const targetDirection = e.currentTarget.dataset.direction;
                
                if (targetDirection === 'up') {
                    dx = 0; dy = -1; direction = 'up';
                }
                if (targetDirection === 'down') {
                    dx = 0; dy = 1; direction = 'down';
                }
                if (targetDirection === 'left') {
                    dx = -1; dy = 0; direction = 'left';
                }
                if (targetDirection === 'right') {
                    dx = 1; dy = 0; direction = 'right';
                }
            }

            // 處理滑動手勢
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            canvas.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            });

            canvas.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            });

            function handleSwipe() {
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                
                if (Math.abs(deltaX) > Math.abs(deltaY)) { // 水平滑動
                    if (deltaX > 30) {
                         dx = 1; dy = 0; direction = 'right';
                    } else if (deltaX < -30) {
                         dx = -1; dy = 0; direction = 'left';
                    }
                } else { // 垂直滑動
                    if (deltaY < -30) { // 向上滑
                         dx = 0; dy = -1; direction = 'up';
                    } else if (deltaY > 30) { // 向下滑
                         dx = 0; dy = 1; direction = 'down';
                    }
                }
            }

            // 全螢幕邏輯
            async function toggleFullScreen() {
                try {
                    if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                        if (mainContent.requestFullscreen) {
                            await mainContent.requestFullscreen();
                        } else if (mainContent.webkitRequestFullscreen) { /* Safari */
                            await mainContent.webkitRequestFullscreen();
                        }
                    } else {
                        if (document.exitFullscreen) {
                            await document.exitFullscreen();
                        } else if (document.webkitExitFullscreen) { /* Safari */
                            await document.webkitExitFullscreen();
                        }
                    }
                } catch (err) {
                    console.error(`全螢幕模式切換失敗: ${err.message}. 這可能是因為執行的環境不支援此功能。`);
                }
            }

            function handleFullscreenChange() {
                if (document.fullscreenElement || document.webkitFullscreenElement) {
                    fullscreenIcon.classList.add('hidden');
                    exitFullscreenIcon.classList.remove('hidden');
                } else {
                    fullscreenIcon.classList.remove('hidden');
                    exitFullscreenIcon.classList.add('hidden');
                }
                // 等待轉換完成，然後調整畫布大小
                setTimeout(() => {
                    setupCanvas();
                    initializeGame(); // 以新的尺寸重新開始遊戲
                }, 150);
            }


            // 事件監聽
            fullscreenButton.addEventListener('click', toggleFullScreen);
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange); // Safari
            document.addEventListener('keydown', handleKeyPress);
            restartButton.addEventListener('click', initializeGame);
            
            document.querySelectorAll('.touch-button').forEach(button => {
                button.addEventListener('click', handleTouch);
            });
            
            window.addEventListener('resize', () => {
                setupCanvas();
                // 在調整大小後可能需要重繪，這裡選擇重新開始遊戲以簡化
                initializeGame();
            });


            // 初始啟動
            setupCanvas();
            initializeGame();
        });
    </script>
</body>
</html>

